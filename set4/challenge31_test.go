package set4

import (
	"bytes"
	"cryptopals/utils"
	"fmt"
	"testing"
	"time"
)

func TestHmacSha1(t *testing.T) {
	// Test cases from https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-and-Guidelines/documents/examples/HMAC_SHA1.pdf
	testArrayMessages := map[int][]byte{
		0: []byte("Sample message for keylen=blocklen"),
		1: []byte("Sample message for keylen<blocklen"),
		2: []byte("Sample message for keylen=blocklen"),
	}

	testArrayKeys := map[int][]byte{
		0: []byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
		},
		1: []byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13,
		},
		2: []byte{
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
			0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
			0x60, 0x61, 0x62, 0x63,
		},
	}

	resultArray := []string{
		"5fd596ee78d5553c8ff4e72d266dfd192366da29",
		"4c99ff0cb1b31bd33f8431dbaf4d17fcd356a807",
		"2d51b2f7750e410584662e38f133435f4c4fd42a",
	}

	for i, testMessage := range testArrayMessages {
		expected := resultArray[i]
		actual := hmacSha1(testArrayKeys[i], testMessage)
		actualCheckSum := fmt.Sprintf("%x", actual)
		if expected != actualCheckSum {
			t.Error("Failed to compute HMAC-SHA1 for", string(testMessage), "expected", expected, "got", actualCheckSum)
		}
	}
}

func TestInsecureCompare(t *testing.T) {
	if insecureCompare([]byte("abc"), []byte("def"), time.Microsecond) == true {
		t.Error("Failed comparing messages, should have received false when messages differ")
	}
	if insecureCompare([]byte("abc"), []byte("abc"), time.Microsecond) == false {
		t.Error("Failed comparing messages, should have received true when messages are equal")
	}
}

func TestTimingLeakAttack(t *testing.T) {
	file, err := utils.GenerateRandomBytes(32)
	if err != nil {
		t.Error("Failed to generate file name")
	}

	serverUrl := mockWebServerUrl(10 * time.Millisecond) // using a value that does not take too much time waiting
	numberOfBytesToRecover := 5                          // recover only first 5 bytes in order to reduce the total time it takes the test to finish (aka brute force time)
	signature := recoverSignatureUsingTimingAttack(file, serverUrl, numberOfBytesToRecover)

	t.Log("Recovered signature is", fmt.Sprintf("%x", signature))

	expectedSignature := getFileSignature(file)

	t.Log("Expected signature was", fmt.Sprintf("%x", expectedSignature))

	if !bytes.Equal(signature[:numberOfBytesToRecover], expectedSignature[:numberOfBytesToRecover]) {
		t.Error("Failed to recover HMAC using timing leak attack")
	}
}
